Базовые форматы подкастов



- документалка
- монолог
- ток-шоу ведущих
- свободный разговор с гостем
- разговор по сценарию с гостем



Тема подкаста - "Процессы и работа с ними"

Процесс - это программа (т.е. объектный код, хранящийся на каком-либо носителе информации), которая находится в состоянии выполнения. Однаком процесс - это не только испольняемый программный код, который в ОС Unix часто назвыются сегментом кода (text section). В процесс также включается набор ресурсов, 



- таких как открытые файлы и 

- сигналы, ожидающие обработки, 

- внутренние данные ядра, 

- состояние процессора, 

- адресное пространство памяти, в которое отображается один или несколько объектов, один или несколько потоков выполнения ядра, а также 

- сегмент данных программы, содержащий глобальные переменные. 

  (Разработка ядра Linux. Роберт Лав)

В принципе, всю указанную выше информацию мы можем найти в `/proc/<PID>`



```bash
root@jmfypfhgwa:~# cat /proc/762252/
arch_status         cmdline             environ             limits              mounts              oom_score           root/               smaps_rollup        task/               
attr/               comm                exe                 loginuid            mountstats          oom_score_adj       sched               stack               timens_offsets      
autogroup           coredump_filter     fd/                 map_files/          net/                pagemap             schedstat           stat                timers              
auxv                cpu_resctrl_groups  fdinfo/             maps                ns/                 patch_state         sessionid           statm               timerslack_ns       
cgroup              cpuset              gid_map             mem                 numa_maps           personality         setgroups           status              uid_map             
clear_refs          cwd/                io                  mountinfo           oom_adj             projid_map          smaps               syscall             wchan               
root@jmfypfhgwa:~# cat /proc/762252/
```



Все основные программы, как, например, ps, top, atop, берут информацию как раз из этой директории и предоставляют информацию в удобочитаемом виде.

Жизнь процесса:

В самом простой модели у процесса имеется три различных состояния:

1. Выполнение - активное состяоние, во время которого процесс обладает всеми необходимыми ему ресурсами. В этом состоянии процесс непосредственно выполняется процессором.
2. Ожидание - пассивное состяоние, во время которого процесс заблокирован, он не может быть выполнен, потому что ождиает какое-то событие, например, ввод данных или освобождения нужного ему устройсвта
3. Готовность - тоже пассивное сотояние, процесс тоже заблокирован, но в олтичи от состяония ождиания, он заблокирован не по внутренним причинам (как, например, ожидание ввода-вывод), а по внешним, независящим от процесса, причинам. В это состояние процесс переводится планировщиком процессов, так как в системе выполняется не только он. В этот состоянии процесс сообщает, что готов к выполнению и ожидает дейсвтий.

Более сложная модель состоит из пяти состояний. Здесь добавляется два состояния

1. Рождение прооцесса - пассивное сотояние, когда самого процесса еще нет, но уже готова структура для появления процесса. 
2. Смерть процесса - самого процесса уже нет, но может случится, что его место, то есть структура, осталась в списке процессов.



1. Создание процесса - это переход из состяония рождения в состояние готовоности
2. Уничтожение процесса - это переход из сотояния выполнения в состояние смерти
3. Восстановление процесса - переход из состояния готовности в соятоние выполнения
4. Изменение приоритета процесса - переход 



Статусы процессов в выводе ps или `/proc/<PID>/stat` или `/proc/<PID>/status`

R - процесс готов к выполнению или уже выполняется. Данные статус присывается сразу двум состояниям процессов, так как не имеет смысла присваивать отедльный статус для готовности, так как заметить его не удастя

D - процесс находится в "беспробудном сне" - ожидает дискового ввода/вывода. Из этого состояния процесс не реагирует ни накакие сигналы

T - процесс останолвение или трасируется отладчиком. В самом простейшем случае процесс можно перевести в него, отправив сигнал SIGSTOP

S - процесс находится в состоянии ожидания, например, ождание пользовательского ввода или же в обещм случае какого-то события

Z - процесс-зомби. Процесс находится в этом сстоянии, если завершил свое выполнение, но не была удалена его структура из памяти, так как например, процесс-родитель не считал код завершения. Обычно в данном случае проблема в процессе родителе. Здесь как вариант, можно попробоват убить процесс родитель, тогда родителем станет init, который уже и может корректно завершить процесс. Хочу обратить внимание, что подобное состояние характерно для ОС с иерархической структурой, где имеется родитель-потомок. Например, в ОС  Windows такого состояния нет, так как все процессы управляются непосредственно диспетчером процессов, поэтому если диспетчер не сможет корректно завершить процесс, то, скорее всего, проблема со всей системой. 

(OpenNet. Процессы в Linux  http://www.opennet.ru/docs/RUS/lnx_process/)

I - данным статусом могут обладать бездейсвтующие потоки ядра

В современной операционной системе процессы предусматривают наличие двух виртуальных ресурсов - виртуального процессора и виртуальной памяти. 

Виртуальный процессор создает для пользовательских процессов иллюзию, что они монопольно используют всю компьютерную систему. 

Виртуальная память позволяет процессу распределять опретивную память компьютера и управлять ею так, как будто он один владеет всей памятью в системе.

Потоки располгаются в общей виртуальной памяти процесса, но каждый из них выполняется на собственном виртуальном процессоре. 

В Linux процесс начинает свое существование в результате вызова функции `fork()`, который создает новый процесс путем копирования существующего. После порождения дочернего процесса родительский процесс продолжает свое выполнение, а дочерний начинает выполняться с одного и того же места - с момента возврата из системной функции  fork(). (стоит отметить, что в своременных ядрах fork() реализована через clone()) 

Для того, чтобы дочерний процесс выполнял какую-нибудь другую программу используются функции из семейста `exec()`, которое позволяет создать новое адресное пространство и загрузить в него новую программу. 





**Сигналы**

Примитивный метод межпроцесоррного взаимодействия (IPC) являются сигналы. Сигнал - это оповещение процесса о том, что произошло некое событие. Иногда сигналы описывают как _программные прерывания_. Сигнал аналогичен аппаратным прерываниям в том смысле, что они останавливают нормальное выполнение программы. В большинстве случаев невозможно предсказать, когда будет доставлен тот или иной сигнал 